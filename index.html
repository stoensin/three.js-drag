
<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - draggable cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!--<script>

    var container, stats;
    var camera, controls, scene, renderer;
    var objects = [];
    var plane = new THREE.Plane();
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            intersection = new THREE.Vector3(),
            INTERSECTED, SELECTED;

    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 1000;

        controls = new THREE.OrbitControls(camera);
        controls.addEventListener('change',render);

        scene = new THREE.Scene();

        scene.add( new THREE.AmbientLight( 0x505050 ) );

        var light = new THREE.SpotLight( 0xffffff, 1.5 );
        light.position.set( 0, 500, 2000 );
        light.castShadow = true;

        light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 200, 10000 ) );
        light.shadow.bias = - 0.00022;

        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;

        scene.add( light );

        var geometry = new THREE.BoxGeometry( 40, 40, 40 );

        for ( var i = 0; i < 50; i ++ ) {

            var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

            object.position.x = Math.random() * 1000 - 500;
            object.position.y = Math.random() * 600 - 300;
            object.position.z = Math.random() * 800 - 400;

            object.rotation.x = Math.random() * 2 * Math.PI;
            object.rotation.y = Math.random() * 2 * Math.PI;
            object.rotation.z = Math.random() * 2 * Math.PI;

            object.scale.x = Math.random() * 2 + 1;
            object.scale.y = Math.random() * 2 + 1;
            object.scale.z = Math.random() * 2 + 1;

            object.castShadow = true;
            object.receiveShadow = true;

            scene.add( object );

            objects.push( object );

        }

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.sortObjects = false;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;

        container.appendChild( renderer.domElement );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> webgl - draggable cubes';
        container.appendChild( info );

        stats = new Stats();
        container.appendChild( stats.dom );

        let hammer = new Hammer(renderer.domElement);

        hammer.on('panstart',function(ev){
            onDocumentMouseDown(ev);
        });
        hammer.on('panmove',function(ev){
            onDocumentMouseMove(ev);
        });
        hammer.on('panend',function(ev){
            onDocumentMouseUp(ev);
        });
        renderer.domElement.addEventListener( 'touchstart', onDocumentMouseMove, false );
        renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
        renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
        renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

        document.onkeydown = function(e){
            keyboard(e);
        };

        //

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseMove( event ) {
//        console.info(event);
        let x,y;
        switch (event.type){
            case 'panmove':
                x = event.pointers[0].clientX;
                y = event.pointers[0].clientY;
                break;
            case 'touchstart':
                x = event.touches[0].clientX;
                y = event.touches[0].clientY;
                break;
            case 'mousemove':
                x = event.clientX;
                y = event.clientY;
        }

        event.preventDefault();

        mouse.x = ( x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( y / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        if ( SELECTED ) {

            if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

                SELECTED.position.copy( intersection.sub( offset ) );

            }

            return;

        }

        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {
            if(event.type == "touchstart"){
                controls.enabled = false
            }

            if ( INTERSECTED != intersects[ 0 ].object ) {

                if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                INTERSECTED = intersects[ 0 ].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

                plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection( plane.normal ),
                        INTERSECTED.position );

            }

            container.style.cursor = 'pointer';

        } else {

            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

            INTERSECTED = null;

            container.style.cursor = 'auto';

        }

    }

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {

            controls.enabled = false;

            SELECTED = intersects[ 0 ].object;

            if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

                offset.copy( intersection ).sub( SELECTED.position );

            }

            container.style.cursor = 'move';

        }

    }

    function onDocumentMouseUp( event ) {

        event.preventDefault();

        controls.enabled = true;

        if ( INTERSECTED ) {

            SELECTED = null;

        }

        container.style.cursor = 'auto';

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {
        renderer.render( scene, camera );
    }

    function keyboard(e){
        switch (e.keyCode){
            case 79 :  //o
                if(camera.zoom <2) {
                    camera.zoom += 0.05;
                    camera.updateProjectionMatrix();
                }
                break;
            case 73:   //i
                if(camera.zoom >0.1) {
                    camera.zoom -= 0.05;
                    camera.updateProjectionMatrix();
                }
                 break;

        }
    }

</script>-->

</body>
</html>
<script src="dist/bundle.js"></script>